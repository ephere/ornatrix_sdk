#include "PrecompiledHeaders.h"

// Uncomment the following macro to enable the check for memory leaks at exit.
// Start the tests in the debugger (F5) with Debug configuration and inspect the list of leaks (from the bottom up) in the Output window once the process exits.
// The first 3 leaks are generated by static variables in Embree. There are also 4 leaks generated by static variables in hull.c
//#define ENABLE_LEAK_CHECK

#ifdef ENABLE_LEAK_CHECK
#	include "Ephere/NativeTools/ParallelFor.h"
#	include <crtdbg.h>

static long BreakAtAllocationId = ( _CrtSetDbgFlag( _CRTDBG_LEAK_CHECK_DF | _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG ) ), 0 );
// Set a breakpoint on the next line and once it hits set BreakAtAllocationId to the id of the first leaked block
static long SetBreakAtAllocationId = BreakAtAllocationId ? _CrtSetBreakAlloc( BreakAtAllocationId ) : 0;
#endif

#include "TestOperator.h"
#include "Ephere/Geometry/Native/Test/Utilities.h"
#include "Ephere/NativeTools/ParallelFor.h"
#include "Ephere/Ornatrix/Ornatrix.h"
#include "Ephere/Ornatrix/Operators/Curler.h"
#include "Ephere/Ornatrix/Private/CommonHair.h"
#include "Ephere/Ornatrix/Private/HairUtilities.h"
#include "Ephere/Ornatrix/Private/Utilities.h"

// Set TBB threads to 1 to simplify debugging
//tbb::task_scheduler_init TbbInit{ 1 };

using namespace std;
using namespace Ephere::Geometry;
using namespace Ephere::Ornatrix;

namespace Ephere::Ornatrix
{
OrnatrixLibrary TheOrnatrixLibrary;

std::wstring const& GetProjectName()
{
	static std::wstring name = L"Ornatrix";
	return name;
}
}

TEST_CASE( "UpdateStrandIdsAndMapping" )
{
	vector<StrandId> strandIds( 4, InvalidStrandId );
	unordered_map<StrandId, int> strandIdsToIndices;

	UpdateStrandIdsAndMapping( strandIds, strandIdsToIndices, 0, vector<StrandId>{ 1000, 0, 1, 2 } );
	REQUIRE( strandIds.size() == strandIdsToIndices.size() );

	UpdateStrandIdsAndMapping( strandIds, strandIdsToIndices, 0, vector<StrandId>{ 0, 1, 2, 1000 } );
	REQUIRE( strandIds.size() == strandIdsToIndices.size() );

	UpdateStrandIdsAndMapping( strandIds, strandIdsToIndices, 3, array { InvalidStrandId } );
	REQUIRE( strandIds[3] == 1000 );

	strandIds.resize( 5, InvalidStrandId );
	UpdateStrandIdsAndMapping( strandIds, strandIdsToIndices, 4, array { InvalidStrandId } );
	REQUIRE( strandIds[4] == HashMix32( 0 ) );
}

TEST_CASE( "DeleteStrandIdByIndex" )
{
	vector<StrandId> strandIds( 4, InvalidStrandId );
	unordered_map<StrandId, int> strandIdsToIndices;

	UpdateStrandIdsAndMapping( strandIds, strandIdsToIndices, 0, vector<StrandId>{ 2, 0, 1, 3 } );
	REQUIRE( strandIdsToIndices.size() == 4 );

	std::vector indexToDelete{ 1 };

	DeleteStrandIdByIndex( strandIds, strandIdsToIndices, indexToDelete );
	REQUIRE( strandIdsToIndices.find( 0 ) == strandIdsToIndices.end() );
	REQUIRE( strandIdsToIndices[2] == 0 );
	REQUIRE( strandIdsToIndices[1] == 1 );
	REQUIRE( strandIdsToIndices[3] == 2 );
}

#if 0
TEST_CASE( "HashMix32 Reversible" )
{
	vector<bool> coverage( 1LL<<32 );
	cout << fixed << setprecision(1);
	for( auto i = 0u; ; ++i )
	{
		auto hash = HashMix32( i );
		if( coverage[hash] )
		{
			FAIL( "Duplicate hash " << hash << ", source " << i << '\n' );
			break;
		}

		coverage[hash] = true;
		if( hash == unsigned( -1 ) )
		{
			cout << "Source for max is " << i << '\n';
		}

		if( ( i & ( ( 1 << 24 ) - 1 ) ) == 0 )
		{
			cout << "i = " << i << " " << ( ( 100.0 * ( i >> 24 ) ) / (1<<8) ) << "%\n";
		}

		if( i == unsigned( -1 ) )
		{
			break;
		}
	}
}
#endif

int main( int argc, char* argv[] )
{
	using namespace Ephere;

#ifdef ENABLE_LEAK_CHECK
	// Disable parallel processing when tracking leaks, TBB generates many leaks
	ParallelForEnabled() = false;
#endif

	SetupTestLogging( L"Ephere.Ornatrix.Static.Test.log" );

	std::string loadError;
	TheOrnatrixLibrary = LoadOrnatrixLibrary( Log::LogDispatcher, GetPythonScripter(), ".", &loadError );
	if( TheOrnatrixLibrary.IsEmpty() )
	{
		std::cout << "Failed to load Ornatrix shared library: " << loadError << '\n';
		return 1;
	}

	if( TheOrnatrixLibrary.library->LoadUsdSerializer() == nullptr )
	{
		std::cout << "Failed to load USD plugin: " << GetLoadDynamicLibraryError() << '\n';
		return 1;
	}

	TheOrnatrixLibrary.grooms->GetTypeRegistry().RegisterType<Groom::Operators::SomeData>();
	Groom::Operators::Test = TheOrnatrixLibrary.grooms->GetOperatorRegistry().Add( Groom::MakeDescriptor<Groom::Operators::TestOperator>( "TestOperator" ) );

	return RunCatchTests( argc, argv );
}
